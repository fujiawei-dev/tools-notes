---
date: 2022-07-12T15:11:48+08:00
author: "Rustle Karl"

title: "Terraform 与其他基础结构即代码工具的比较"
url:  "posts/tools/docs/terraform/intro"  # 永久链接
tags: [ "Tools", "README" ]  # 标签
categories: [ "Tools 学习笔记" ]  # 分类

toc: true  # 目录
draft: true  # 草稿
---

如果在网络上搜索“**基础结构即代码**”，则很容易找到最受欢迎的工具列表：

- Chef
- Puppet
- Ansible
- SaltStack
- Terraform

所有这些工具都以代码形式管理基础架构。并且所有这些工具都是开源的，并由大型贡献者社区支持，可以与许多不同的云提供商配合使用（CloudFormation 是非开源的且仅支持 AWS）。那么该如何决定使用哪个工具呢？

如果您去查找上述工具之间的对比，大多数的比较都只不过列出了每个工具的一般属性，听起来使用任何一个工具上都能达到目标。

## 1. 可变基础架构(Mutable Infrastructure)与不可变基础架构(Immutable Infrastructure)

**Chef，Puppet，Ansible 和 SaltStack 等配置管理工具通常默认为可变基础架构。**例如，如果您告诉 Chef 安装新版本的 OpenSSL，它将在您现有的服务器上运行软件更新，更改将就地进行。随着时间的流逝，随着您应用越来越多的更新，每台服务器都会建立唯一的更改历史记录。这通常会导致一种称为**配置漂移**，其中每台服务器与所有其他服务器都略有不同，从而导致难以诊断且几乎无法重现的细微配置错误。

如果您使用诸如 Terraform 之类的配置工具来部署由 Docker 或 Packer 创建的机器映像，那么每个“更改”实际上就是一个新服务器的部署。例如，要部署新版本的 OpenSSL，您可以使用 Packer 或 Docker 创建一个新映像，并安装新版本的 OpenSSL，然后在一组全新服务器上部署该映像，然后取消部署旧服务器。这种方法减少了**配置漂移**的可能性，使您更容易准确地知道服务器上正在运行的软件，并允许您随时轻松地部署该软件的任何先前版本。

## 2. 程序性(Procedural)与声明性(Declarative)

**Chef 和 Ansible 采用程序性代码**，在此过程中，您可以编写代码逐步指定如何实现最终状态。

**Terraform,CloudFormation,SaltStack 和 Puppet 都采用声明性代码**，您可以直接编写代码指定所需的最终状态，而 IAC 工具本身负责确定如何实现该状态。

例如，假设您要部署 10 台服务器（在 AWS 术语中为“EC2 实例”）来运行应用程序的 v1。这是 Ansible 模板的简化示例，可通过程序方法来完成此任务：

```yaml
- ec2:
    count: 10
    image: ami-v1 
    instance_type: t2.micro
```

以下是 Terraform 模板的简化示例，该模板使用声明性方法执行相同的操作：

```ini
resource "aws_instance" "example" {
    count = 10
    ami = "ami-v1"
    instance_type = "t2.micro"
}
```

现在看来这两种方法很相似，并且当您最初使用 Ansible 或 Terraform 执行它们时，它们将产生相似的结果。**但是我们需要注意的是，当您要进行更改时会发生什么。**

假设流量增加了，您想将服务器数量增加到 15 个。使用 Ansible，您先前编写的过程代码将不再有用。如果您仅将服务器数量更新为 15，然后重新运行该代码，它将部署 15 台新服务器，总共 25 台！因此，您必须知道以前已经部署了多少服务器，并编写新的脚本来添加 5 个新服务器：

```yaml
- ec2:
    count: 5
    image: ami-v1 
    instance_type: t2.micro
```

使用**声明性代码**，由于您要做的就是声明所需的结束状态，并且 Terraform 会弄清楚如何达到该结束状态，**Terraform 还知道它过去创建的任何资源**。因此，如果需要将服务器数量增加到 15 个，您要做的就是回到 Terraform 脚本并将服务器数量从 10 更新为 15：

```ini
resource "aws_instance" "example" {
    count = 15
    ami = "ami-v1"
    instance_type = "t2.micro"
}
```

如果执行此模板，Terraform 将意识到它已经创建了 10 台服务器，因此只需要做的就是创建 5 台新服务器。

**在这个问题中展现了 IAC 工具的两个主要问题：**

1. 在处理Ansible这些程序性代码时，**基础架构的状态没有完全展示在代码中**，我们需要阅读所有的 Ansible 脚本而且知道这些脚本的执行顺序，才有可能知道基础架构的最终状态。
2. **程序性代码的可重用性非常低**，由于状态不断变化，先前的代码可能不再可用。结果随着时间的推移，过程代码库往往非常庞大而复杂。

**在 Terraform 中使用的声明性代码中，代码始终代表基础结构的最新状态**。一目了然，可以知道当前部署了什么以及如何配置，而不必担心历史记录或执行顺序。这也使创建可重用的代码变得容易，因为不必考虑当前的状态。只需要专注于描述最终状态，Terraform 会指出如何自动从一种状态转换为另一种状态。结果，Terraform 代码库往往保持较小且易于理解。

## 3. 代理与无代理

**Chef，Puppet 和 SaltStack 都要求您在要配置的每台服务器上安装代理软件**（例如Chef Client，Puppet Agent，Salt Minion）。该代理通常在每台服务器上在后台运行，并负责安装最新的配置管理更新，这带来了一些缺点：

- **维护：**必须定期定期更新代理软件，如果有的话，请注意使其与主服务器保持同步。您还必须监视代理软件，并在崩溃时重新启动它。
- **安全性：**如果代理软件从主服务器（如果不使用主服务器，则从其他服务器）下载配置，则必须在每台服务器上打开出站端口。如果主服务器将配置推送到代理，则必须在每台服务器上打开入站端口。

如果使用 Terraform 就无需担心上述问题：只需发出请求命令，云提供商的代理即可在所有服务器上执行命令。

## 二级

### 三级

```bash

```

```bash

```

